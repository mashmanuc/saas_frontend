# UX-план: редактор предметів та мов (v0.84)

## 0. Принципи

1. **Доменна сегментація.** Користувач працює з окремими картками предметів і мов. Ніяких «довгих списків» без структури.
2. **Спрямованість на маркетплейс.** Кожна обрана категорія → тег у `subjects[].tags` або `languages[].tags`, що відразу використовується у фільтрах каталогу.
3. **Швидкий старт + глибоке налаштування.** Популярні предмети/мови доступні за 1 клік, але завжди є розширений пошук.
4. **Прозоре збереження.** Користувач бачить статус «Збережено» після будь-якої зміни у картці.

## 1. Структура екрана «Предмети та мови»

### 1.1 Header
- Назва кроку + короткий опис («Оберіть предмети та опишіть, з ким і як ви працюєте»).
- Системні підказки: «Що більше вкладок ви заповните — тим точніше вас знайдуть учні».

### 1.2 Панель вибору
| Блок | Вміст | UX | Дані |
|------|-------|----|------|
| **Основні предмети** | Сітка карток (Math, UA, History, English, Physics, Chemistry, Biology, Geography, Informatics, Art, Music, …) | Натиснув → предмет одразу у «Вибрані» | додаємо `{ code, tags: [] }` |
| **Мови (популярні)** | Чіпси: English, German, Polish, French, Spanish, Italian, Czech, Slovak, Romanian, Hungarian, Dutch, Portuguese, Chinese, Greek, Latin | Натиснув → мова додається в «Вибрані мови» | `{ code, level: null, tags: [] }` |
| **Мови (інші)** | Поле пошуку + довгий список (scroll) | при виборі показується badge «Додано» | код мови з каталогу |

### 1.3 Секція «Вибрані предмети»
- Кожен предмет рендериться як акордеон-картка.
- Кнопки: «Розгорнути», «Видалити», «Дублювати налаштування» (опційно).

### 1.4 Секція «Вибрані мови»
- Та ж логіка, але з мовними вкладками.

## 2. Вкладки для предмета

| Вкладка | Тип UI | Значення (tags) | Примітки |
|---------|--------|-----------------|----------|
| **Класи** | Toggle-чіпси | `class_1_4`, `class_5_9`, `class_10_11` | можна обрати кілька |
| **Іспити** | Toggle-чіпси | `exam_nmt`, `exam_dpa`, `exam_zno` | зберігаємо навіть якщо ЗНО legacy |
| **Цілі** | Toggle-чіпси | `goal_level_up`, `goal_tests`, `goal_gaps`, `goal_homework` | копіюємо у JSON tags |
| **Формат** | Radio або multi? → обираємо multi (онлайн/очно) | `format_online`, `format_offline` | якщо офлайн → просимо вказати локацію (future) |
| **Аудиторія** | Toggle-чіпси | `audience_pupils`, `audience_applicants`, `audience_students`, `audience_adults` | |
| **Опис / підхід** | Textarea (0–800 символів) | `description` (зберігаємо у `subjects[].custom_direction_text`) | показуємо лічильник символів |

### Збереження
- Кожна вкладка має auto-save on blur/change.
- Під карткою статус «Збережено о 12:34».

## 3. Вкладки для мови

| Вкладка | Тип UI | Значення | Зберігання |
|---------|--------|----------|------------|
| **Рівень (CEFR)** | Radio-чіпси | A1, A2, B1, B2, C1, C2, Native | поле `level` + тег `level_*` |
| **Формат** | Toggle-чіпси | онлайн/очно | `format_online`, `format_offline` |
| **Цілі** | Toggle-чіпси | `goal_school`, `goal_conversation`, `goal_exam`, `goal_work_travel` |
| **Аудиторія** | Toggle-чіпси | `audience_kids`, `audience_teens`, `audience_adults` |
| **Опис / підхід** | Textarea | `languages[].description` | |

## 4. Дані та API

### 4.1 Фронтенд модель
```ts
interface SubjectCard {
  code: string
  tags: string[] // класи, іспити, цілі, формат, аудиторія
  description?: string // custom_direction_text
}

interface LanguageCard {
  code: string
  level: LanguageLevel | null
  tags: string[] // формат, цілі, аудиторія, рівень як тег
  description?: string
}
```

### 4.2 Payload до API
```json
{
  "subjects": [
    {
      "code": "mathematics",
      "tags": ["class_5_9", "exam_nmt", "goal_tests", "format_online"],
      "custom_direction_text": "Готую до НМТ за 8 тижнів..."
    }
  ],
  "languages": [
    {
      "code": "en",
      "level": "C1",
      "tags": ["format_online", "goal_conversation", "audience_adults"],
      "description": "Курс для бізнес-англійської"
    }
  ]
}
```

### 4.3 Back-end
- Використовуємо наявні `TutorSubject` та `TutorSubjectTag`.
- Для мов створюємо аналог `TutorLanguage` + `TutorLanguageTag` (якщо ще нема).
- Словники тегів тримаємо у `SubjectTag` / `LanguageTag` (seed).

## 5. UX-деталі

1. **Порожні стани:** якщо немає вибраних предметів — показати мікрокарту «Оберіть предмет, щоб додати налаштування».
2. **Серіалізація вибору:** обмежити до 5 предметів та 5 мов (щоб не робили 50 карток) — правило можна змінити.
3. **Хлібні крихти:** вгорі картки показувати бейджі з уже обраними тегами (наприклад, «Класи: 5–9, 10–11»).
4. **Клавіатурна навігація:** чіпси керуються стрілками + Enter.
5. **Accessibility:** контраст 4.5:1, aria-label для кожної вкладки.

## 6. Роадмап впровадження

1. **UX/UI дизайн** (Figma) – 2 дні.
2. **Frontend реалізація** – 4 етапи:
   1. Refactor SubjectTagsSelector → SubjectSelectionPanel + SubjectCardList.
   2. Реалізація вкладок для предметів (компонент TabbedCard).
   3. Реалізація вкладок для мов (re-use TabbedCard).
   4. Інтеграція з autosave + store.
3. **Backend** – 2 етапи:
   - Розширення serializer для tags/description.
   - Синхронізація з таблицями тегів.
4. **QA** – сценарії:
   - Додавання/видалення предмета.
   - Зміна тегів → payload.
   - Відображення на маркетплейсі.

## 7. Узгодження з проблемою #11
- Документ формалізує вимогу «структуровані вкладки для предметів/мов».
- Після реалізації потрібно оновити TUTOR_ONBOARDING_ISSUES_v083.md → перевести пункт #11 у статус «в роботі», коли буде затверджений дизайн.

## 8. Відкриті питання
1. Чи дозволяємо дублювати опис для декількох предметів? (можна додати кнопку «копіювати налаштування на інший предмет»).
2. Чи треба обмежити кількість тегів у кожній вкладці? (наприклад, максимум 3 цілі).
3. Чи зберігати «Популярні мови» у конфігу, щоб не хардкодити?

---
**Наступний крок:** затвердити цей план, потім переходити до дизайн-макету (Figma) та розробки.

## 9. Збереження конфігів під час оновлення БД

**Ціль:** жодні довідники предметів/мов/тегів не повинні зникати при очищенні або міграції БД.

### 9.1 Джерело правди
- Тримаємо всі довідники у git-версійованих JSON/TS файлах:
  - `backend/apps/marketplace/data/subjects.json`
  - `backend/apps/marketplace/data/subject_tags.json`
  - `backend/apps/marketplace/data/languages.json`
  - `backend/apps/marketplace/data/language_tags.json`
- Формат: список об’єктів з `code`, `title_uk`, `title_en`, `category`, `order`, `is_popular` тощо.

### 9.2 Seed-команди
- Оновлюємо management-команди `seed_categories` та `seed_subjects_i18n`, щоб вони:
  1. Завжди читали джерело з JSON.
  2. Виконували upsert (`update_or_create`) по `code`.
  3. Підтримували `--flush` прапорець для очищення довідника перед завантаженням.
- Додаємо окремі команди для тегів, наприклад `seed_subject_tags`, `seed_language_tags`.

### 9.3 Міграції / CI
- Додаємо крок у CI/CD та локальні README: після `manage.py migrate` автоматично запускати `seed_subjects` + `seed_tags`.
- Для продакшену: seed-команди idempotent, тому безпечно виконуються на кожному деплої.

### 9.4 Резервне копіювання даних тьютора
- Дані, які вводить тьютор (вибрані предмети, tags, описи) зберігаються у власних таблицях (`TutorSubject`, `TutorSubjectTag`, `TutorLanguage`, `TutorLanguageTag`).
- Для dev середовища додаємо `dumpdata --natural-primary-key` перед wipe БД, щоб мати можливість швидко відновити тестових користувачів.

### 9.5 Документація
- Оновити `docs/USERS.md` або окремий `docs/data-seeding.md` з інструкцією: «Що робити перед очищенням БД».
- У TUTOR_ONBOARDING_ISSUES додати пункт, що всі довідники мають підтримуватися через seed-файли.
