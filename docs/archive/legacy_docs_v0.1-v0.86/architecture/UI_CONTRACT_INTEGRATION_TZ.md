# Технічне завдання: інтеграція UI Contract System

## 1. Мета
Запровадити ізольовану бібліотеку `assets2/ui-contract` як фундаментальний UI-шар для всієї платформи, забезпечивши сумісність з існуючим темінгом, поступову міграцію компонентів та відсутність регресій у продуктивності, доступності й контрактних API.

## 2. Результати аудиту
1. **Архітектура**: `ui-contract` містить токени (`tokens.css`), набір базових контролів (Button, Modal, Select, Dropdown, FormField) та документацію з правилами використання. Стилі інкапсульовано через CSS Modules, токени наслідують глобальні змінні `src/assets/main.css`, що гарантує узгодженість тем.
2. **Теми**: бібліотека покладається на `data-theme` і CSS-змінні, тож автоматично підтримує light/dark/classic. Потребує гарантії, що root елемент отримує атрибут (Pinia store це вже робить).
3. **Доступність**: компоненти мають aria-атрибути, focus-trap (Modal), клавіатурну навігацію (Dropdown/Select). Потрібні smoke-тести на реальних сценаріях.
4. **Залежності**: лише Vue 3 (Composition API) + локальні CSS. Немає зовнішніх пакетів, що спрощує інтеграцію.
5. **Ризики**:
   - Паралельні кастомні стилі можуть конфліктувати (особливо глобальні кнопки/inputs). Потрібне очищення legacy SCSS.
   - Відсутні складніші контролі (таблиці, date-picker). Фази мають включати план розширення або обгортання сторонніх компонентів.
   - Потрібен контроль за i18n: компоненти не містять тексту, але споживачі мають підключати ключі.
6. **Оппортуніті**: єдина система токенів, швидке масштабування тем, можливість reuse в майбутніх продуктах.

## 3. Scope
- Впровадження глобальних токенів `ui-contract` у фронтенд застосунок.
- Міграція критичних контролів (кнопки, form fields, модалки, дропдауни, select) у визначених модулях.
- Актуалізація документації та тестів (unit, E2E, accessibility).
- Визначення плану розширення бібліотеки під додаткові сценарії (таблиці, тости, плашки статусів).

## 4. Вимоги
1. **Технічні**
   - Обовʼязковий імпорт `@/assets2/ui-contract/tokens/tokens.css` у `src/main.js` або `App.vue` до рендера додатку.
   - Заборонено перевизначати стилі компонентів через глобальні селектори/`!important`. Дозволено лише layout-класи.
   - Усі нові UI-компоненти фронтенду повинні будуватися на токенах `ui-contract`.
   - Якщо компоненту бракує функціоналу, зміни вносяться в бібліотеку централізовано, а не локальними патчами.
2. **Доступність**
   - Валідація focus states, aria-атрибутів, керування з клавіатури (WCAG 2.1 AA).
   - Modal: обовʼязкові автотести на focus-trap і повернення фокусу після закриття.
3. **Тести**
   - Vitest: покриття основних props/станів для кожного адаптованого компоненту.
   - Cypress/Playwright: smoke-флоу для екрану, де зʼявився новий کنترل.
4. **Документація**
   - Оновити `docs/architecture` (цей файл + діючі специфікації модулів) з описом використання `ui-contract`.
   - У релізних документах `docs/plan/vX.Y/vX.Y.0 frontend.md` додати секцію FE↔BE: ендпоїнти, sequence та error→UX mapping, якщо змінюються інтерфейси.

## 5. Фази впровадження
### Фаза 0 — Підготовка
- Імпорт токенів у root та smoke-тест тем (light/dark/classic).
- Перевірка, що `document.documentElement` отримує коректний `data-theme`.
- Створення QA-checklist та оновлення Storybook/Playground (за потреби).

### Фаза 1 — Пілотний модуль
- Обрати один високоприорітетний флоу (наприклад, редагування профілю викладача).
- Замінити локальні кнопки, інпути, модалки, дропдауни на `ui-contract`.
- Додати unit + e2e тести на цей флоу, оновити документацію.
- Виміряти продуктивність (LCP/CLS) і переконатися у відсутності регресій.

### Фаза 2 — Розширення
- Скласти список решти модулів з пріоритетами та залежностями.
- Для кожного модуля: підготувати mini-TЗ (контакти з BE, винятки), виконати міграцію, оновити тести й документувати.
- Розширити бібліотеку, якщо потрібні додаткові контролі (checkbox, radio, tabs, toast). Кожне розширення — окремий пакет змін з тестами.

### Фаза 3 — Стандартизація
- Заборонити нові компоненти поза `ui-contract` без архітектурного погодження.
- Налаштувати lint-правила/кодуаналіз для контролю використання токенів.
- Внести `ui-contract` у Platform Manifest як обовʼязковий фундаментальний шар.

## 6. Acceptance Criteria
- Токени підключені глобально, теми перемикаються без регресій.
- Принаймні один ключовий флоу працює на `ui-contract` і пройшов e2e перевірку.
- Усі зміни задокументовано, релізні плани оновлені.
- Створено backlog фаз 2–3 із визначеними строками/відповідальними.

## 7. Ризики та Mitigation
| Ризик | Вплив | Mitigation |
|-------|-------|------------|
| Конфлікт стилів з legacy SCSS | Середній | Поступове відключення глобальних стилів у модулі після міграції; в ревʼю перевіряти `scoped`/CSS Modules |
| Недостатнє покриття тестами | Високий | Обовʼязкові unit + e2e smoke на кожну фазу, інтегрувати в CI |
| Відсутність потрібних контролів | Середній | Планувати розширення бібліотеки наперед, PRD/дизайн на нові компоненти перед фазою 2 |
| Тема/токени не синхронізуються | Низький | Smoke-тести тем, перевірка `data-theme`, моніторинг у QA |

## 8. План комунікацій
- Архітектурний ревʼю кожної фази (Front/Back техрадам). 
- QA sign-off після кожної хвилі.
- Оновлення релізних нотаток із переліком екранів, які мігрували.

## 9. UI Migration Policy (Mandatory)
1. **Загальний принцип**: міграція виконується лише через версіонування доменів. Змішування Legacy UI та UI Contract у межах одного екрану/домену заборонено.
2. **Legacy UI (read-only)**: існуючі екрани до впровадження `ui-contract` вважаються Legacy та не підлягають рефакторингу. Дозволено лише критичні bugfix та security/accessibility виправлення. Будь-які візуальні покращення чи часткові заміни компонентів заборонені.
3. **UI Contract UI (V2 Domain Rule)**: кожна міграція створює V2-домен (наприклад, `tutorProfileV2`) із виключним використанням компонентів `assets2/ui-contract`. Заборонено імпортувати legacy-стилі або старі компоненти.
4. **Заборона часткової міграції**: не допускається заміна окремих контролів у legacy-файлах. Дозволено лише повністю новий V2-екран із можливістю порівняння та перемикання через feature-flag/route/env.
5. **Контроль версій та відкат**: перед стартом міграції ставимо git-tag `frontend-freeze-pre-ui-contract`. Legacy і V2 співіснують паралельно, видалення Legacy відбувається лише після стабілізації V2.
6. **UI Contract як SSOT**: після запуску V2 `assets2/ui-contract` стає єдиним джерелом UI. Усі нові контролі додаються тільки в бібліотеку.
7. **Архітектурний інваріант**: якщо є сумнів, чи можна змінювати UI в конкретному місці — відповідь "ні" для Legacy і "так" для V2 через `ui-contract`. Порушення правил прирівнюється до архітектурної помилки.

## 10. Доменний план міграції (Legacy → V2)

| Домен | Legacy джерело (read-only) | Що переносимо без змін (копія) | Що переписуємо у V2 | Коментар / V2 локація |
|-------|---------------------------|---------------------------------|----------------------|------------------------|
| **Auth** | `src/modules/auth` (views, layouts, MFA flows) | API клієнт `auth/api/authApi.js`, Pinia-стор `auth/store/authStore.js`, утиліти (storage, telemetry) — копіюються у V2 без правок | Усі `views/*`, `components/*` (форм-фактори, layout) переписати на ui-contract; нові шаблони авторизації, MFA, WebAuthn | Новий каталог `src/modules/authV2` з власним роутером та ui-contract компонентами |
| **Profile (user/tutor)** | `src/modules/profile` (views + widgets) | Stores `profile/store/*.js`, API-проксі, utils — переносяться без змін (до V2/services) | `views/ProfileEditView.vue`, `ProfileOverviewView.vue`, `UserAccountView.vue`, `Settings*`, NEW-файли — переписати з нуля у `profileV2/views` використовуючи ui-contract; компоненти у `profile/components` реімплементувати | V2: `src/modules/profileV2` із підпапками `views`, `components`, `forms` |
| **Marketplace (catalog + tutor profile)** | `src/modules/marketplace` | Domain services: `stores/catalogStore.ts`, `api/*`, search utils — копіюємо 1:1 | Всі `views` (TutorCatalog, TutorProfile, SearchResults, Category, MyProfile), UI-компоненти `components/*` — переписати під новий дизайн | Створити `marketplaceV2` з окремими entry routes; legacy storefront лишається недоторканою |
| **Booking / Availability** | `src/modules/booking` (грид календаря, availability editor) | Pinia stores (`stores/availabilityStore.ts`, `requestsStore.ts`), API клієнти, domain mappers | `views/TutorAvailabilityView.vue`, календарні компоненти в `components/availability/*` — нова реалізація з ui-contract формами, таймлайн-компонентами; legacy CSS не чіпаємо | Каталог `bookingV2` із розбиттям на `calendar`, `requests`, `components` |
| **Billing** | `src/modules/billing` | `billing/api`, `billing/stores/billingStore.ts`, пагінація utils — копія без змін | `views/AccountBillingView.vue`, `components/*` (платіжні карти, статуси, модалки) переписати на ui-contract; форми checkout/cancel оформити новими контролами | Новий каталог `billingV2` + ізольований маршрут в роутері |
| **Onboarding / Dashboard shell** | `src/modules/onboarding`, `src/modules/dashboard` | Бекенд контракти (API, stores) переносимо як є | Усі мультікрокові екрани (`OnboardingView.vue`, `ChecklistView.vue`, `DashboardTutor.vue`, `DashboardStudent.vue`) будуються з ui-contract layout-ами; card-компоненти переписати | `onboardingV2`, `dashboardV2` з модульною структурою (layout, widgets, steps) |
| **Shared UI** | `src/ui`, `src/components` | Бізнес-логіка в composables (`src/composables/*`), сервісні плагіни (router guards) — без змін | Усі візуальні shared-компоненти (кнопки, модалки, форми) не використовуються у V2; натомість створюємо фічеві обгортки над `assets2/ui-contract` | Додати `src/componentsV2/` для адаптерів (наприклад, `FormSection`, `Toolbar`) |

### Порядок дій для кожного домену
1. **Freeze legacy**: після створення V2-каталогу ставимо прапор read-only в README домену, додаємо посилання на цю політику.
2. **Копія сервісів**: переносимо API/Store/Utils у V2 `/services` без змін. Код підписуємо як `Legacy-compatible` до повної заміни.
3. **Роутинг**: у `src/router/index.js` додаємо паралельні маршрути `*-v2` з feature-flag (env/remote config). Старі маршрути не правимо.
4. **UI-реалізація**: створюємо нові `views` з ui-contract компонентами, layout/sections/controls отримують токени через CSS vars, без імпорту legacy стилів.
5. **Перевірка контрактів**: звіряємо API-виклики й state machines між Legacy та V2, документуємо відмінності в `docs/plan/...` та в новому README домену.
6. **Відкат**: поки V2 не стабілізований, маршрути легко вимикаються feature-flagʼом; після стабілізації — план деcommission Legacy.

## 11. Політика доменних термінів та текстів
1. **Ніяких нових термінів без потреби**: якщо домен уже має назву поля/секції/стану — повторно використовуємо існуючий термін. Заборонено вигадувати альтернативні “креативні” назви.
2. **Семантика незмінна**: локалізаційні ключі відображають доменну структуру. Зміна тексту не може змінювати значення поля (наприклад, не перетворюємо “Hourly rate” на “Marketing tagline”).
3. **Helper-тексти**: дозволені лише для пояснення вже визначених полів. Заборонено дробити один сенс на кілька вигаданих підказок.
4. **Нові терміни**: якщо домену реально бракує поняття, спершу погоджуємо його з архітектором/доменним лідами, документуємо у відповідному README/архітектурному файлі, лише потім додаємо ключ.
5. **Рев’ю**: кожен PR з новими i18n-ключами має містити посилання на доменну специфікацію або пояснення, чому з’явився новий термін.

---
**Відповідальний за виконання:** команда фронтенду (агентні моделі).  Керівний документ — цей ТЗ + Manifest платформи.
